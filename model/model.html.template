<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>{{ escape(name) }} model</title>
<style>
body { margin: 0; overflow: hidden; }
canvas { width: 100%; height: 100%; }
</style>
<!-- Imports -->
<script src="/js/three.min.js"></script>
<script src="/js/LoaderSupport.js"></script>
<script src="/js/OBJLoader2.js"></script>
<script>
var RADS_PER_SEC = 0.25; // rotation speed in radians per second
var obj = null;
// Once the page is loaded we setup the ThreeJS environment and load the OBJ file
var renderer, camera, canvas;
window.addEventListener('load', () => {
    canvas = document.getElementById('model');

    // Set up the renderer
    renderer = new THREE.WebGLRenderer({canvas:canvas});
    renderer.setClearColor(0xd0d0d0, 1); // light gray background
    renderer.sortObjects = false; // for efficiency

    // Setup the scene and lights
    var scene = new THREE.Scene();
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    var light = new THREE.DirectionalLight(0xffffff, 0.7);
    light.position.set(1, 1, 1);
    scene.add(light);

    // Setup the camera and render size
    on_resize();
    window.addEventListener('resize', on_resize);

    // Setup the material for the object
    // This uses Lambert material for efficiency since the primary goal is to display on a Raspberry Pi
    var material = new THREE.MeshLambertMaterial({color:0xffffff});
    material.name = "";
    material.side = THREE.DoubleSide;

    // Load the object
    function obj_loaded(event) {
        obj = event.detail.loaderRootNode;
        // Scale and position the object in the middle of the scene
        obj.children[0].geometry.computeBoundingSphere();
        var sphere = obj.children[0].geometry.boundingSphere;
        var scale = 1/sphere.radius;
        // Original lines modify obj's scale, position, and rotation properties directly:
        // obj.scale.set(scale, scale, scale);
        // obj.position.copy(sphere.center).negate().divideScalar(sphere.radius);
        let position_matrix = new THREE.Matrix4().setPosition(sphere.center.clone().negate().divideScalar(sphere.radius));
        obj.scaled_position_matrix = position_matrix.scale(new THREE.Vector3(scale, scale, scale));
        obj.matrixAutoUpdate = false;
        scene.add(obj);
    }

    var loader = new THREE.OBJLoader2();
    loader.setDisregardNormals(true);
    loader.setUseIndices(true);
    loader.setMaterials({"": material});
    loader.setLogging(false, false);
    loader.load('{{ url_escape(name) }}.obj', obj_loaded, null, console.error, null, true);

    // Rendering loop
    let done = false;
    var last_redraw = 0;
    function animate(ms) {
        if (obj !== null) {
            if (ms && last_redraw) {
                var elapsed_ms = ms - last_redraw;

                obj.rotation.x += RADS_PER_SEC * elapsed_ms / 1000;
                obj.rotation.y += RADS_PER_SEC * elapsed_ms / 1000;
                obj.rotation.x %= 2*Math.PI;
                obj.rotation.y %= 2*Math.PI;
                
                // Need to do XY order
                let rotation = new THREE.Matrix4().makeRotationX(obj.rotation.x).multiply(new THREE.Matrix4().makeRotationY(obj.rotation.y));
                obj.matrix = rotation.multiply(obj.scaled_position_matrix);
                last_redraw = ms;
            } else { last_redraw = performance.now(); }
        } else { last_redraw = 0; }
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }
    animate();
});

function on_resize() {
    renderer.setSize(window.innerWidth, window.innerHeight);
    var w = canvas.width, h = canvas.height;
    //var camera = new THREE.PerspectiveCamera(75, w / h, 1, 5);
    //camera.position.z = 1;
    camera = (w > h) ?
        new THREE.OrthographicCamera(-w/h, w/h, 1, -1, -2, 2) :
        new THREE.OrthographicCamera(-1, 1, h/w, -h/w, -2, 2);
}
</script>
</head>
<body>
<!-- the canvas element we will draw on -->
<canvas id="model"></canvas>
</body>
</html>
